{
  "verilog-01-basics-syntax": {
    "id": "VF-01",
    "title": "Verilog 01 – Basics & Syntax",
    "difficulty": "Beginner",
    "description": "Learn fundamental Verilog syntax and module structure",
    "sections": [
      {
        "title": "1. Introduction",
        "content": "Verilog is a Hardware Description Language used to model digital circuits."
      },
      {
        "title": "2. Verilog Module Structure",
        "content": "A Verilog design begins with a module.",
        "syntax": "module module_name (port_list);",
        "example": "module and_gate(input a, input b, output y);\nassign y = a & b;\nendmodule"
      },
      {
        "title": "3. Data Types in Verilog",
        "content": "wire, reg, and integer are commonly used data types.",
        "vectors": "reg [7:0] data;\nwire [3:0] addr;"
      },
      {
        "title": "4. Operators",
        "content": "Bitwise, logical, and arithmetic operators are supported.",
        "example": "assign y = (a & b) | (~c);"
      },
      {
        "title": "5. Continuous Assignment",
        "content": "Used for combinational logic.",
        "example": "assign sum = a ^ b;\nassign carry = a & b;"
      },
      {
        "title": "6. Procedural Blocks",
        "content": "Procedural blocks describe behavior.",
        "subSections": [
          {
            "title": "6.1 Combinational Logic",
            "code": "always @(*) begin\n  y = a + b;\nend"
          },
          {
            "title": "6.2 Sequential Logic",
            "code": "always @(posedge clk) begin\n  q <= d;\nend"
          }
        ]
      },
      {
        "title": "7. Control Statements",
        "content": "Decision-making using if–else and case.",
        "subSections": [
          {
            "title": "If–Else Example",
            "code": "if (sel == 0)\n  out = a;\nelse\n  out = b;"
          },
          {
            "title": "Case Example",
            "code": "case (sel)\n  2'b00: out = a;\n  default: out = 0;\nendcase"
          }
        ]
      },
      {
        "title": "8. Example Circuits",
        "content": "Basic circuits implemented in Verilog.",
        "subSections": [
          {
            "title": "2:1 Multiplexer",
            "code": "assign y = sel ? b : a;"
          },
          {
            "title": "D Flip-Flop",
            "code": "always @(posedge clk)\n  q <= d;"
          }
        ]
      },
      {
        "title": "9. Common Beginner Mistakes",
        "content": "- Using = instead of <=\n- Missing sensitivity lists"
      }
    ]
  },


  "verilog-02-combinational-logic": {
    "id": "VF-02",
    "title": "Verilog 02 – Combinational Logic",
    "difficulty": "Beginner",
    "description": "Model combinational circuits using Verilog constructs",
    "sections": [
      {
        "title": "1. Introduction",
        "content": "Combinational logic is a type of digital logic where the output depends only on the current inputs.\nThis module focuses on modeling combinational circuits using Verilog."
      },
      {
        "title": "2. Logic Gates in Verilog",
        "content": "Common logic gates and their operators:\nAND (&)\nOR (|)\nNOT (~)\nXOR (^)",
        "example": "assign y = (a & b) | (~c);"
      },
      {
        "title": "3. Continuous Assign Statements",
        "content": "The assign keyword is used to model combinational logic.",
        "example": "assign sum = a ^ b;\nassign carry = a & b;"
      },
      {
        "title": "4. always @(*) for Combinational Logic",
        "content": "Procedural modeling of combinational logic:",
        "example": "always @(*) begin\n    y = a & b;\nend"
      },
      {
        "title": "5. Multiplexers",
        "content": "2:1 Multiplexer example:",
        "example": "assign y = sel ? b : a;"
      },
      {
        "title": "6. Decoders",
        "content": "2:4 Decoder using case statement:",
        "example": "case (a)\n  2'b00: y = 4'b0001;\n  2'b01: y = 4'b0010;\n  2'b10: y = 4'b0100;\n  default: y = 4'b1000;\nendcase"
      },
      {
        "title": "7. Common Mistakes",
        "content": "- Missing default cases\n- Latch inference\n- Incorrect assignment operators"
      }
    ]
  }
,

  "verilog-03-sequential-logic": {
    "id": "VF-03",
    "title": "Verilog 03 – Sequential Logic",
    "difficulty": "Beginner",
    "description": "Understand clocked logic, flip-flops, and state-based design",
    "sections": [
      {
        "title": "1. Introduction",
        "content": "Sequential logic depends on current inputs and past values.\nThis module introduces clocked logic."
      },
      {
        "title": "2. Clocking",
        "content": "Sequential logic uses clock edges.",
        "example": "always @(posedge clk)"
      },
      {
        "title": "3. Flip-Flops",
        "content": "D Flip-Flop example:",
        "example": "always @(posedge clk) begin\n    q <= d;\nend"
      },
      {
        "title": "4. Registers",
        "content": "Registers store multiple bits.",
        "example": "reg [7:0] data_reg;"
      },
      {
        "title": "5. Reset Logic",
        "content": "Synchronous reset example:",
        "example": "if (rst) q <= 0;"
      },
      {
        "title": "6. Counters",
        "content": "4-bit counter:",
        "example": "count <= count + 1;"
      },
      {
        "title": "7. Blocking vs Non-Blocking",
        "content": "Use <= for sequential logic.\nUse = for combinational logic."
      },
      {
        "title": "8. Common Mistakes",
        "content": "- Using blocking assignments in clocked logic\n- Missing reset handling"
      }
    ]
  },
"verilog-04-testbenches": {
    "id": "VF-04",
    "title": "Verilog 04 – Testbenches",
    "difficulty": "Beginner",
    "description": "Verify Verilog designs using simulation testbenches",
    "sections": [
      {
        "title": "1. Introduction",
        "content": "Testbenches verify Verilog designs and are not synthesized."
      },
      {
        "title": "2. Testbench Structure",
        "content": "Basic testbench layout:",
        "example": "module tb;\n// signals\n// DUT\nendmodule"
      },
      {
        "title": "3. DUT Instantiation",
        "content": "Connecting the design under test:",
        "example": "dff dut (.clk(clk), .d(d), .q(q));"
      },
      {
        "title": "4. Initial Blocks",
        "content": "Used to apply stimulus once at simulation start."
      },
      {
        "title": "5. Clock Generation",
        "content": "Clock generation example:",
        "example": "always #5 clk = ~clk;"
      },
      {
        "title": "6. Stimulus",
        "content": "Applying input changes over time."
      },
      {
        "title": "7. Display Statements",
        "content": "Using $display and $monitor."
      },
      {
        "title": "8. Common Mistakes",
        "content": "- No clock generation\n- Expecting synthesis of testbench code"
      }
    ]
},
  "systemverilog-01-from-verilog": {
    "id": "SV-01",
    "title": "SystemVerilog 01 – From Verilog to SystemVerilog",
    "description": "Understand why SystemVerilog was introduced and how it improves RTL design and verification.",
    "difficulty": "Intermediate",
    "sections": [
      {
        "title": "1. Introduction",
        "content": "SystemVerilog is an extension of Verilog designed to support modern hardware design and verification.\n\nIt improves readability, safety, and scalability while remaining backward compatible with Verilog."
      },
      {
        "title": "2. Why SystemVerilog was Introduced",
        "content": "Verilog had limitations in large-scale designs.\n\n• Confusing reg and wire usage\n• Manual sensitivity lists caused bugs\n• Limited verification capabilities"
      },
      {
        "title": "3. Key Improvements Over Verilog",
        "content": "SystemVerilog introduces:\n\n• Unified design and verification language\n• Richer data types like logic, bit, and int\n• Specialized always blocks for clearer intent"
      },
      {
        "title": "4. Enhanced Procedural Blocks",
        "content": "SystemVerilog introduces intent-specific always blocks.",
        "subSections": [
          {
            "title": "always_comb (Combinational Logic)",
            "code": "always_comb begin\n  y = a & b;\nend"
          },
          {
            "title": "always_ff (Sequential Logic)",
            "code": "always_ff @(posedge clk) begin\n  q <= d;\nend"
          },
          {
            "title": "always_latch (Latch Logic)",
            "code": "always_latch begin\n  if (en)\n    q <= d;\nend"
          }
        ]
      },
      {
        "title": "5. logic Data Type",
        "content": "The logic data type replaces reg in most RTL designs.\n\n• Can be assigned in procedural blocks\n• Prevents accidental multiple drivers\n• Cleaner and safer than reg"
      },
      {
        "title": "6. Example: Sequential Logic",
        "example": "logic q;\n\nalways_ff @(posedge clk) begin\n  q <= d;\nend"
      },
      {
        "title": "7. Common Beginner Mistakes",
        "content": "• Using always instead of always_ff\n• Mixing blocking and non-blocking assignments\n• Using wire unnecessarily instead of logic"
      }
    ]
  },
  "systemverilog-02-data-types": {
    "id": "SV-02",
    "title": "SystemVerilog 02 – Data Types, Arrays, and typedef",
    "description": "Learn SystemVerilog’s rich data type system including logic, arrays, typedef, struct, and union.",
    "difficulty": "Intermediate",
    "sections": [
      {
        "title": "1. Introduction",
        "content": "SystemVerilog provides a rich and expressive type system.\n\nThese types help write cleaner, safer, and more maintainable RTL and testbench code."
      },
      {
        "title": "2. SystemVerilog Data Types",
        "content": "Commonly used SystemVerilog data types:\n\n• logic – general-purpose 4-state signal\n• bit – 2-state signal, commonly used in testbenches\n• int, byte, shortint, longint for numeric data",
        "example": "logic a;\nbit b;\nint count;\nbyte data_byte;"
      },
      {
        "title": "3. logic vs reg vs wire",
        "content": "wire is used for continuous assignments.\n\nreg is deprecated in SystemVerilog.\n\nlogic is the preferred replacement and should be used for most signals.",
        "example": "logic data;\n\nassign data = a & b;"
      },
      {
        "title": "4. Packed Arrays",
        "content": "Packed arrays represent bit vectors and are stored as a single contiguous set of bits.",
        "syntax": "logic [7:0] data;",
        "example": "logic [15:0] instruction;"
      },
      {
        "title": "5. Unpacked Arrays",
        "content": "Unpacked arrays represent collections of elements stored separately.",
        "syntax": "logic mem [0:255];",
        "example": "logic buffer [0:31];"
      },
      {
        "title": "6. Packed and Unpacked Together",
        "content": "Packed and unpacked arrays are commonly used together to model memories.",
        "example": "logic [7:0] mem [0:255];"
      },
      {
        "title": "7. typedef",
        "content": "typedef is used to create reusable data types.\n\nIt improves readability and reduces duplication.",
        "example": "typedef logic [7:0] byte_t;\n\nbyte_t data;"
      },
      {
        "title": "8. struct",
        "content": "struct is used to group related signals together.\n\nCommonly used in interfaces and testbenches.",
        "example": "typedef struct packed {\n  logic valid;\n  logic [7:0] data;\n} packet_t;"
      },
      {
        "title": "9. union",
        "content": "union allows multiple interpretations of the same data.\n\nUseful for protocol decoding and debugging.",
        "example": "typedef union packed {\n  logic [31:0] word;\n  logic [3:0][7:0] bytes;\n} data_u;"
      },
      {
        "title": "10. Common Mistakes",
        "content": "• Confusing packed and unpacked array order\n• Overusing wire instead of logic\n• Not using typedef for repeated declarations"
      }
    ]
  }
}
